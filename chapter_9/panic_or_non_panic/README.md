# 언제 `Panic!` 을 써야 하고 언제 `Result`를 반환할지 어떻게 결정해야하는가?

코드가 패닉을 일으킬 때는 복구할 방법이 없다.
복구 가능한 방법이 있든 혹은 그렇지 않든 작성자는 어떤 에러 상황에 대해 `panic!`을 호출할 수 있지만 `panic!`을 호출할 때는 항상 프로그램이 더 이상 실행될 수 없는 상황임을 명확히 해야한다.

`Result`값을 반환하는 선택을 한다면, 호출하는 코드에게 결단을 내려주기보다는 옵션을 제공하는 것이다.
해당 Function의 사용자는 자신의 상황에 맞게 선택할 수 있게 된다.

그러므로, 실패할지도 모르는 함수를 정의할 때는 `Result`를 반환하는 것이 좋다.

## 프로토타입 코드, 테스트 코드, 예제 코드 등에서는 `panic!`을 일으켜도 괜찮다.

테스트 중에 오류가 발생했다는것은 테스트가 실패했다는것으 의미하므로 `panic!`을 일으켜 테스트를 실패하도록 한다.
이때 `unwrap`이나 `expect`를 사용하여 간단하게 테스트를 실패하도록 만들 수 있다.

## 컴파일러보다 작성자가 더 많은 정보를 가지고 있을 때

```rust
use std::net::IpAddr

fn main() {
    let home = "127.0.0.1".parse::<IpAddr>().unwrap();
}
```

위 코드에서는 하드코딩된 스트링을 파싱하여 `IpAddr`인스턴스를 만드는중이다.
우리는 `127.0.0.1`이 유요한 IP 주소임을 볼 수 있으므로, 여기서 `unwrap`을 사용하는 것은 허용된다.
그러나, 하드코딩된 유효한 스트링을 갖고 있다는 것이 `parse`메소드의 반환 타입을 변경해주지는 안흔다.
`parse`는 여전히 `Result`값을 가지고 있고 컴파일러는 마치 `Err` variant가 나올 가능성이 여전히 있는 것처럼
우리가 `Result`를 처리 하는것 처럼 처리를 한것인데, 그 이유는 컴파일러가 해당 스트링이 항상 유효항 IP주소 라는 것을 알 수 있을 만큼 똑똑하지 않기때문이다.

> 만약 IP 주소 스트링이 프로그램 내에 하드코딩된 것이 아니라 사용자로부터 입력 되었다면 더 강건한 방식으로 `Result`를 처리할 필요가 있다.

## 에러 처리를 위한 가이드라인

작성자의 코드가 결국 나쁜 상태에 처하게 될 가능성이 있을 때는 `panic!`을 넣는 것이 바람직하다. 여기서 나쁜 상태란 어떤 가정, 보장, 계약, 혹을 불변성이 깨질 때를 뜻하는 것으로, 이를테면 유효하지 않은 값이나 모슨되는 값, 혹은 찾을 수 없는 값이 작정자의 코드를 통과할 경우를 말한다.

- 이 나쁜 상태란 것이 가끔 벌어질 것으로 예상되는 무언가는 아니다.
- 그 시점 이후의 코드는 나쁜 상태에 있지 않아야만 할 필요가 있다.
- 작성자가 사용하고 있는 타입 내에 에러가 발생 하였을때 대신 집어 넣을만한 것이 없다.

## 유효성을 위한 커스텀 타입 생성하기

러스트의 타입 시스템을 이용하여 유요한 값을 보장하는 아이디어에서 한 발 더 나가서, 유효성을 위한 커스텀 타입을 생성하는 것을 살펴보다

2장의 추리 게임을 상기 해 보면, 우리의 코드는 사용자에게 1부터 100 사이의 숫자를 추측하도록 요청하였다. 우리는 실제로 사용자의 추측 값이 우리의 비밀 숫자와 비교하기 전에 해당 값이 유효한지 확인 하지 않았다.

이로 인해 큰 문제는 발생하지는 않는다 `match`를이용해서 `Too High` 와 `Too Low` 로 출력햇던 값은 맞는 말이니까.

하지만 사용자가 범위 밖의 값을 추측하여 입력하였을 때 유효성을 검사하여 사용자에게 응답하는 것은 쓸모 있는 향상일 것이다.

이를 위한 한 가지 방법은 `u32` 대신 `i32`로서 추측 값을 파싱하여 음수가 입력될 가능성을 허용하고, 그리고나서 아래와 같이 숫자가 범위 내에 있는지에 대한 검사를 추가하는 것이다.

```rust
fn main() {
    loop {
        let guess: i32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        if guess < 1 || guess > 100  {
            println!("The secret number will be between 1 and 100.");
            continue;
        }

        match guess.cmp(&secret_number) {
            // snip
        }
    }
}
```

`if` 표현식은 사용자의 입력 값이 범위 밖에 있는 지혹은 그렇지 않은지 검사하고, 사용자에게 문제점을 말해준후 `continue`를 호출하여 루프의 다음 반복을 시작하고 다른 추측값을 요청한다.

하지만, 이는 이상적인 해결책이 아니다. 만일 프로그램이 오직 1과 100사이의 값에서만 동작하는 것이 전적으로 중요하고, 많은 함수가 이러한 요구사항을 가지고 있다면, 모든 함수 내에서 이렇게 검사를 하는것은 지루할 것이다.(그리고 잠재적으로 성능에 영향을 줄 것이다.)

대신, 우리는 새로운 타입을 만들어서, 유효성 확인을 모든 곳에서 반복하는 것보다는 차라리 그 타입의 인스턴스를 생성하는 함수 내에 유효성 확일을 넣을 수 있다. 이 방식에서, 함수가 그 시그니처 내에서 새로운 타입을 이용하고 받은 값을 자신 있게 사용하는 것은 안전하다.

```rust
pub struct Guess {
    value: u32
}

impl Guess {
    pub fn new(value: u32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess {
            value
        }
    }

    pub fn value(&self) -> u32 {
        self.value
    }
}
```

> `new` 함수가 1과 100사이의 값을 받았을 때에만 인스턴스를 생성하는 `Guess`타입 정의

`new`라는 이름의 연관 함수는 `u32`타입의 값인 `value`를 파라미터로 받고 `Guess`를 반환 하도록 정의 되어있다. `new`함수의 본체에 있는 코드는 `value`가 1부터 100사이의 값인지 확인하는 테스트를 한다. 만익 `value`가 이 테스트에 통과하지 못하면 `panic!`을 호출하며, 이는 이 코드를 호출하는 프로그래머에게 고쳐야 할 버그가 있을을 알려주는데, 범위 밖의 `value`를 가지고 `Guess`를 생성하는 것은 `Guess::new`가 필요로 하는 `계약`을 위반 하기 때문이다.
